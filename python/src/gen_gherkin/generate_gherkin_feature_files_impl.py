"""The AaC Generate Gherkin Feature Files plugin implementation module."""

# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

# There may be some unused imports depending on the definition of the plugin, be sure to remove unused imports.
import yaml

from os import path
from typing import Any, Callable

from aac.context.definition import Definition
from aac.context.language_context import LanguageContext
from aac.context.source_location import SourceLocation
from aac.execute.aac_execution_result import (
    ExecutionResult,
    ExecutionStatus,
    ExecutionMessage,
    MessageLevel,
)
from aac.in_out.parser._parse_source import parse

from aac.in_out.files.aac_file import AaCFile
from aac.plugins.check import run_check
from aac.plugins.generate import run_generate

plugin_name = "Generate Gherkin Feature Files"


def gen_gherkin_behaviors(
    architecture_file: str, output_directory: str
) -> tuple[list, ExecutionResult]:
    """
    Business logic for allowing gen-gherkin-behaviors command to perform Generate Gherkin feature files from AaC model behavior scenarios.

    Args:
        architecture_file (str): The YAML file containing the data models from which to generate Gherkin feature files.
        output_directory (str): The directory into which the generated Gherkin feature files will be written.

    Returns:
        The results of the execution of the gen-gherkin-behaviors command.
    """
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []

    # write parsing method that outputs a dictionary
    # parsing method needs to get behaviors and model_requirements
    # create generator file
    # run generate

    definitions_dictionary = parse(architecture_file)

    results = _get_template_properties(definitions_dictionary)

    new_files = []
    for result in results:
        for model in results:
            yaml_list = []
            for behavior_entry in model["behaviors"]:
                yaml_list.append([{"model": {"name": model["name"], "behavior": behavior_entry, "model_requirements": model["model_requirements"]}}])

            new_file = ""
            for yaml_object in yaml_list:
                new_file = new_file + yaml.safe_dump_all(yaml_object, default_flow_style=False, sort_keys=False, explicit_start=True)
            new_files.append(new_file)

    if len(result) < 1:
        msg = ExecutionMessage(
            "No applicable data to generate a feature file",
            MessageLevel.ERROR,
            None,
            None,
        )
        messages.append(msg)
        return None, ExecutionResult(plugin_name, "gen-gherkin-behaviors", ExecutionStatus.GENERAL_FAILURE, messages)

    messages.append(f"Successfully generated templates to directory: {output_directory}")
    status = ExecutionStatus.SUCCESS

    return new_files, ExecutionResult(plugin_name, "gen-gherkin-behaviors", status, messages)


def _get_template_properties(parsed_models: dict) -> list[dict]:
    """
    Generate a list of template property dictionaries for each gherkin feature file to generate.

    Args:
        parsed_models: a dict of models where the key is the model name and the value is the model dict

    Returns:
        a list of template property dictionaries
    """
    def collect_models(parsed_models: list[dict]) -> dict:
        """Return a structured dict like parsed_models, but only consisting of model definitions."""
        collected_models = []
        for model in parsed_models:
            if model.get_root_key() == "model":
                collected_models.append(model)

        return collected_models

    def sanitize_scenario_step_entry(step: str) -> str:
        """Remove any conflicting keyword from the scenario step."""
        if does_step_start_with_gherkin_keyword(step):
            return step.split(None, 1)[1]
        return step

    def collect_and_sanitize_scenario_steps(scenario: dict) -> list[dict]:
        """Collect and sanitize scenario steps then return template properties for a 'scenarios' entry."""
        if "description" in scenario:
            description = scenario["descrption"]
        else:
            description = "TODO: Fill out this feature description."  # noqa: T101
        scenario_steps = [
            {
                "definition": description,
                "givens": [sanitize_scenario_step_entry(given) for given in scenario["given"]],
                "whens": [sanitize_scenario_step_entry(when) for when in scenario["when"]],
                "thens": [sanitize_scenario_step_entry(then) for then in scenario["then"]],
            }
        ]
        return scenario_steps

    def collect_behavior_entry_properties(behavior_entry: dict) -> list[dict]:
        """Produce a list of template property dictionaries from a behavior entry."""
        feature_name = behavior_entry["name"]
        if "description" in behavior_entry:
            feature_description = behavior_entry["description"]
        else:
            feature_description = "TODO: Fill out this feature description."  # noqa: T101
        behavior_scenarios = []
        behavior_requirements = []
        scenario_lists = []
        if "acceptance" in behavior_entry:
            for acceptance in behavior_entry["acceptance"]:
                if "scenarios" in acceptance:
                    for scenario in acceptance["scenarios"]:
                        scenario_lists.append(collect_and_sanitize_scenario_steps(scenario))
        if "requirements" in behavior_entry:
            for requirement in behavior_entry["requirements"]:
                behavior_requirements.append(requirement)

        return[
            {
                "feature": {"name": feature_name, "description": feature_description},
                "scenarios": [scenario for scenario_list in scenario_lists for scenario in scenario_list],
                "behavior_requirements": behavior_requirements,
            }
        ]

    def collect_model_behavior_properties(model: Definition) -> dict:
        """
        Produce a template property dictionary for each behavior entry in a model.

        Args:
            model: A model containing behavior properties

        Returns:
            A dictionary containing a list of behaviors and a list of requirements
        """
        behaviors = []
        requirements = []
        behavior_lists = []
        features = []
        scenarios = []
        behavior_requirements = []
        if "behavior" in model.content:
            for behavior in model.structure["model"]["behavior"]:
                behaviors.append(behavior)
                if "requirements" in behavior:
                    for requirement in behavior["requirements"]:
                        requirements.append(requirement)
        for behavior in behaviors:
           behavior_lists.append(collect_behavior_entry_properties(behavior))
        returning_list = {
            "name": model.name,
            "behaviors": [behavior for behavior_list in behavior_lists for behavior in behavior_list],
            "model_requirements": requirements
        }

        return returning_list

    def does_step_start_with_gherkin_keyword(step: str) -> bool:
        """
        Check if a string starts with a Gherkin keyword.

        Gherkin keywords can be found here: https://cucumber.io/docs/gherkin/reference/#keywords
        """
        gherkin_keywords = [
            "Feature",
            "Rule",
            "Example",
            "Given",
            "When",
            "Then",
            "And",
            "But",
            "Background",
            "Example",
            "Scenario",
            "Scenario Outline",
            "Scenario Template",
        ]

        return step.startswith(tuple(gherkin_keywords))

    return [collect_model_behavior_properties(model) for model in collect_models(parsed_models)]


def after_gen_gherkin_behaviors(architecture_file: str, output_directory: str, run_generate: Callable) -> ExecutionResult:
    """
    """
    new_files, execution_status = gen_gherkin_behaviors(architecture_file, output_directory)

    generator_file = path.abspath(path.join(path.dirname(__file__), "./behavior_generator.aac"))

    for new_file in new_files:
        print(new_file)
        return run_generate(
            aac_plugin_file=new_file,
            generator_file=generator_file,
            code_output=output_directory,
            test_output="",
            doc_output="",
            no_prompt=True,
            force_overwrite=True,
            evaluate=False,
        )
